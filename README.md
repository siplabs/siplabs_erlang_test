<p>Пояснения к решению:</p>
<p>	     Общее описание - функция start/2  получает вторым параметром список запущенных Erlang-узлов с одинаковыми куками. Пример списка ['node1@pc','node2@pc']. Первый параметр start/2 игнорируется и введен для совместимости с application:start/1. Далее, на каждом узле запускается процесс, реализующий API - loop/0. Каждый узел опрашивается на количество ядер, чтобы сбалансировать нагрузку. Далее, при выполнении calc/1 на каждой ноде вызывается функция distribute, которая запускает фнкцию mul_decimated_seq на каждом доступном ядре. При выполнении этой функции генерируется ряд, прореженный общим мколичеством ядер в сети. Например, если всего в распределенной сети 2 компьютера по 4 ядра в каждом, то каждое ядро будет генерировать натуральный ряд, в который включен только каждый восьмой член ряда. Такое распределение, в отличии от последовательного, когда первое ядро считает первые N чисел, а второе ядро - вторые N, обеспечивает лучшее распределение нагрузки между ядрами, что замечается при больших N. После окончания вычислений, каждое ядро пересылает свой результат следующему по цепочке ядру, которое домножает его на свой результат вычислений и передает дальше. Это узкое место т.к. в конечном счёте последние N умножений (где N-количество ядер в сети) выполняется последовательно. Эту проблему можно было бы решить, строя не цепочки вычислений, а деревья, но небыло найдено приемлемого по сложности и объему кода решения.</p>
<p>	     Стоит отметить один недостаток программы - она не запускается через application:start/1, это связано с решением передавать список нод в функцию start/2, а не явно вшивать в программу, но на деле не удалось найти решения, сохраняющего этот список к моменту вызова функции calc/1 - функции put\get и кажется register не сохраняют своих значений, если вызывать из через application:start/1, поэтому, начинать работу с программой нужно будет функцией novice:start(0, ['список узлов']).</p>